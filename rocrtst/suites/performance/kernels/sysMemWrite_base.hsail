module &m:1:0:$base:$large:$default;
extension "amd:gcn";
extension "IMAGE";

decl prog function &abort()();

prog kernel &__SysMemStore(kernarg_u64 %bufStart,
                           kernarg_u64 %bufEnd,
                           kernarg_u64 %addrStep,
                           kernarg_u64 %deadArg) {

  // Directives for Compiler
  pragma  "AMD RTI", "ARGSTART:__SysMemStore";
  pragma  "AMD RTI", "version:3:1:104";
  pragma  "AMD RTI", "device:generic";
  pragma  "AMD RTI", "uniqueid:1024";
  pragma  "AMD RTI", "function:1:0";
  pragma  "AMD RTI", "memory:64bitABI";
  pragma  "AMD RTI", "uavid:8";
  pragma  "AMD RTI", "privateid:8";
  pragma  "AMD RTI", "ARGEND:__SysMemStore";

  // Retrieve the values of input arguments
  // bufStart refers to the starting byte address
  // bufEnd refers to the end of byte address
  // addrStep refers to the product of total number
  // of work-items in the grid * sizeof(uint32_t)
  ld_kernarg_u64     $d0, [%bufStart];
  ld_kernarg_u64     $d1, [%bufEnd];
  ld_kernarg_u64     $d2, [%addrStep];
  ld_kernarg_u64     $d3, [%deadArg];

  // Compute the absolute id of current thread
  // and shift it by two to get index into user
  // buffer to access for Write operation
  workitemflatabsid_u32  $s0;
  shl_u32            $s0, $s0, 2;

  // Convert the thread id into a 64-bit number
  // and add it to the starting address of user
  // buffer to obtain effective address for access
  cvt_u64_u32     $d4, $s0;
  add_u64         $d0, $d0, $d4;


@loop:

  // Write sixteeen values with a stride that is
  // determined by the total number of work-items
  // in the global grid

  st_global_u32   $s0, [$d0];
  add_u64         $d0, $d0, $d2;

  st_global_u32   $s0, [$d0];
  add_u64         $d0, $d0, $d2;

  st_global_u32   $s0, [$d0];
  add_u64         $d0, $d0, $d2;

  st_global_u32   $s0, [$d0];
  add_u64         $d0, $d0, $d2;

  st_global_u32   $s0, [$d0];
  add_u64         $d0, $d0, $d2;

  st_global_u32   $s0, [$d0];
  add_u64         $d0, $d0, $d2;

  st_global_u32   $s0, [$d0];
  add_u64         $d0, $d0, $d2;

  st_global_u32   $s0, [$d0];
  add_u64         $d0, $d0, $d2;

  st_global_u32   $s0, [$d0];
  add_u64         $d0, $d0, $d2;

  st_global_u32   $s0, [$d0];
  add_u64         $d0, $d0, $d2;

  st_global_u32   $s0, [$d0];
  add_u64         $d0, $d0, $d2;

  st_global_u32   $s0, [$d0];
  add_u64         $d0, $d0, $d2;

  st_global_u32   $s0, [$d0];
  add_u64         $d0, $d0, $d2;

  st_global_u32   $s0, [$d0];
  add_u64         $d0, $d0, $d2;

  st_global_u32   $s0, [$d0];
  add_u64         $d0, $d0, $d2;

  st_global_u32   $s0, [$d0];
  add_u64         $d0, $d0, $d2;

  // Loop until we hit end of buffer [%bufEnd]
  cmp_lt_b1_u64   $c0, $d0, $d1;
  cbr_b1          $c0, @loop;

};

